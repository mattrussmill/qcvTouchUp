#include "colorselectionwidget.h"
#include "mousewheeleatereventfilter.h"
#include "ui_colorselectionwidget.h"
#include <QPixmap>
#include <QImage>
#include <QPainter>
#include <QMouseEvent>
#include <QPoint>

#include <QDebug>

ColorSelectionWidget::ColorSelectionWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ColorSelectionWidget)
{
    ui->setupUi(this);
    MouseWheelEaterEventFilter *wheelFilter = new MouseWheelEaterEventFilter(this);
    ui->verticalSlider_ValueSelect->installEventFilter(wheelFilter);

    //setup pixmaps via populating color scanlines - 7 distinct colors in Qt HSV Color Wheel (http://doc.qt.io/qt-5/qcolor.html)
    QImage paletteDisplay = QImage(7, 10, QImage::Format_RGB888);
    selectedColor_m = QColor(Qt::lightGray);
    valueDisplay_m = QImage(1, 10, QImage::Format_RGB888);

    int hue;
    for(int x = 0; x < 7; x++)
    {
        //hue ranges from 0 - 359
        hue = (360 - (60 * x)) % 360;
        for(int y = 0; y < 10; y++)
        {
            //saturation & value set 10 y intensities to yield smoother interpolation results opposed to 2
            paletteDisplay.setPixelColor(x, y, QColor::fromHsv(hue, 255 - 255 * (y + 1) / 10.0, 255 - 40 * (y + 1) / 10.0));
        }
    }

    //use hardware to interpolate inbetween colors
    ui->label_PaletteVisual->setPixmap(QPixmap::fromImage(paletteDisplay)
                                       .scaled(ui->label_PaletteVisual->width(), ui->label_PaletteVisual->height(),
                                               Qt::IgnoreAspectRatio, Qt::SmoothTransformation));

    //set initial menu items
    ui->verticalSlider_ValueSelect->setValue(selectedColor_m.value());
    populateColorValues();

    //connect signals and slots
    connect(ui->verticalSlider_ValueSelect, SIGNAL(valueChanged(int)), this, SLOT(setColorFromPalette()));
    connect(ui->verticalSlider_ValueSelect, SIGNAL(valueChanged(int)), this, SLOT(populateColorValues()));
}

//autogenerated destructor
ColorSelectionWidget::~ColorSelectionWidget()
{
    delete ui;
}

void ColorSelectionWidget::mouseReleaseEvent(QMouseEvent *event)
{
    if(event->button() == Qt::LeftButton)
    {
        QPoint mousePosition = ui->label_PaletteVisual->mapFromParent(event->pos());
        if(mousePosition.x() >= 0 && mousePosition.y() >= 0
                && mousePosition.x() < ui->label_PaletteVisual->width()
                && mousePosition.y() < ui->label_PaletteVisual->height())
        {
            palettePoint_m = mousePosition;
            //paint pixmap
            setColorFromPalette();
            populateColorValues();
            //emit color
        }
    }
    QWidget::mouseReleaseEvent(event);
}

void ColorSelectionWidget::mouseMoveEvent(QMouseEvent *event)
{
    if(!event->pos().isNull())
    {
        QPoint mousePosition = ui->label_PaletteVisual->mapFromParent(event->pos());
        if(mousePosition.x() >= 0 && mousePosition.y() >= 0
                && mousePosition.x() < ui->label_PaletteVisual->width()
                && mousePosition.y() < ui->label_PaletteVisual->height())
        {
            palettePoint_m = mousePosition;
            //paint pixmap
            setColorFromPalette();
            populateColorValues();
        }
    }
    QWidget::mouseMoveEvent(event);
}

void ColorSelectionWidget::mousePressEvent(QMouseEvent *event)
{
    if(event->button() == Qt::LeftButton)
    {
        QPoint mousePosition = ui->label_PaletteVisual->mapFromParent(event->pos());
        if(mousePosition.x() >= 0 && mousePosition.y() >= 0
                && mousePosition.x() < ui->label_PaletteVisual->width()
                && mousePosition.y() < ui->label_PaletteVisual->height())
        {
            palettePoint_m = mousePosition;
            //paint pixmap
            setColorFromPalette();
            populateColorValues();
        }
    }
    QWidget::mousePressEvent(event);
}

void ColorSelectionWidget::setColor(const QColor *color)
{

}

void ColorSelectionWidget::setColorFromPalette()
{
    //remember y axes is inverted because qimage and x is because hue phase shift reversed
    int hue = 359 - 359 * palettePoint_m.x() / static_cast<float>(ui->label_PaletteVisual->width() - 1);
    int saturation = 255 - 255 * palettePoint_m.y() / static_cast<float>(ui->label_PaletteVisual->height() - 1);
    selectedColor_m = QColor::fromHsv(hue, saturation, ui->verticalSlider_ValueSelect->value());
}

void ColorSelectionWidget::paintCursorOnPalette()
{
    //need pixmap to be a member?
}

void ColorSelectionWidget::populateColorValues()
{
    //see comments in constructor for value-bar generation
    for(int y = 0; y < 10; y++)
    {
        valueDisplay_m.setPixelColor(0, y, QColor::fromHsv(selectedColor_m.hue(), 255, 255 - 255 * (y + 1) / 10.0));
    }
    ui->label_ValueVisual->setPixmap(QPixmap::fromImage(valueDisplay_m)
                                     .scaled(ui->label_ValueVisual->width(), ui->label_ValueVisual->height(),
                                             Qt::IgnoreAspectRatio, Qt::SmoothTransformation));

    QImage color(1, 1, QImage::Format_RGB888);
    color.setPixelColor(0, 0, selectedColor_m);
    ui->label_Color->setPixmap(QPixmap::fromImage(color).
                               scaled(ui->label_Color->width(), ui->label_Color->height(),
                                      Qt::IgnoreAspectRatio, Qt::FastTransformation));

    //blockSignals(true);
    ui->spinBox_Red->setValue(selectedColor_m.red());
    ui->spinBox_Green->setValue(selectedColor_m.green());
    ui->spinBox_Blue->setValue(selectedColor_m.blue());
    ui->spinBox_Hue->setValue(selectedColor_m.hue());
    ui->spinBox_Saturation->setValue(selectedColor_m.saturation());
    ui->spinBox_Value->setValue(selectedColor_m.value());
    ui->lineEdit_HTML->setText(selectedColor_m.name());
    //blockSignals(false);
}

//make virt fns
